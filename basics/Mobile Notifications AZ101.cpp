// https://www.learning.algozenith.com/problems/Mobile-Notifications-AZ101-359

/*

Description

You recently bought a new mobile phone. There are N applications in the phone and all generate notifications. There are 3 types of events

1 X - A new notification is generated by application X
2 X - You read all notifications by application X, you may re-read some notifications
3 Y - You read the first Y notifications in the phone. Note that you don’t read the first Y unread notifications, you just read the first Y notifications and you might re-read a few notifications. It is guaranteed that there have been Y notifications before this. 
After every event, find the number of unread notifications in the mobile phone.


Input Format

The first line of the input contains one integer T - the number of test cases. Then T test cases follow.

The first line of each test case contains two space-separated integers N Q - the number of applications and the number of queries.

Each of the next Q lines contains two space-separated integers Z X or Z Y - the description of each event.


Output Format

For each test case, find the number of unread notifications in the mobile phone after every event.


Constraints

1≤ T ≤ 105

1≤ N, Q ≤ 105

1≤ Z ≤ 3

1≤ X ≤ N

1≤ Y ≤ Q

It is guaranteed that the sum of N and the sum of Q over all test cases does not exceed 106.


Sample Input 1

2 
3 4 
1 1 
1 3 
3 2 
2 1 
5 6 
1 4 
1 3 
1 5 
3 3 
1 2 
2 4

Sample Output 1

1
2
0
0
1
2
3
0
1
1

Note

For the first test case,

Application 1 generates a notification
Application 3 generates a notification
Read the first 2 notifications.
Read all notifications by application 1
For the second test case, 

Application 4 generates a notification
Application 3 generates a notification
Application 5 generates a notification
Read the first 3 notifications
Application 2 generates a notification
Read all notifications by application 4

*/


#include <bits/stdc++.h>
using namespace std;

#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);

int main() {
    IOS
    int t;
    cin >> t;
    while (t--) {
        int n, q1;
        cin >> n >> q1;
        //Create a queue to store all notification
        queue<pair<int,int>> q;
        //Create a queue for each application
        queue<int> q2[n+1];
        int cur = 0;
        bool mark[q1+1] = {};
        int i = 1;
        while(q1--) {
            int t, x;
            cin >> t >> x;
            if(t == 1) {
                //Push notifiation with query id in application x
                q2[x].push(i);
                //Push notification in a queue
                q.push({i, x});
                cur++;
                i++;
            }
            else if(t == 2) {
                //Empty all notifications from queue x
                while(!q2[x].empty()) {
                    int y = q2[x].front();
                    //Pop the notification and marked it as 1
                    q2[x].pop();
                    mark[y] = 1;
                    cur--;
                }
            }
            else {
                //Pop notification from q until it's id <= x
                while(!q.empty() && q.front().first <= x) {
                    int a = q.front().first;
                    int b = q.front().second;
                    //Pop notification from queue
                    q.pop();
                    //If the notification is not already popped out, then popped it from
                    //that application queue as well.
                    if(!mark[a]) {
                        mark[a] = 1;
                        q2[b].pop();
                        cur--;
                    }
                }
            }
            cout << cur << "\n";
        }
    }
    return 0;
}
